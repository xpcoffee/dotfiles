#!/bin/bash
set -e

# Configuration
USER_PREFIX="emerick"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Find the repo context using the consolidated directory layout.
#
# Layout:
#   repo/                    ← container (REPO_DIR)
#     main/ (or master/)     ← main branch checkout (MAIN_REPO)
#     emerick/               ← user worktrees (WORKTREES_DIR)
#       feature/             ← individual worktree
#
# Sets: REPO_DIR, MAIN_REPO, REPO_NAME, WORKTREES_DIR, DEFAULT_BRANCH
find_repo_context() {
    local git_root git_dir

    if git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
        git_dir=$(git rev-parse --git-dir 2>/dev/null)

        if [[ "$git_dir" == *"/worktrees/"* ]]; then
            # In a worktree — git-dir: /path/to/repo/main/.git/worktrees/name
            MAIN_REPO="${git_dir%%/.git/worktrees/*}"
        else
            # In a regular git checkout
            MAIN_REPO="$git_root"
        fi

        local main_basename
        main_basename=$(basename "$MAIN_REPO")

        if [[ "$main_basename" == "main" || "$main_basename" == "master" ]]; then
            DEFAULT_BRANCH="$main_basename"
            REPO_DIR=$(dirname "$MAIN_REPO")
        else
            # Fallback: we're in a git repo but the basename isn't main/master.
            # This might be the old layout or an unrelated repo.
            # Try treating it as a standalone repo (old-style detection).
            REPO_DIR=$(dirname "$MAIN_REPO")
            DEFAULT_BRANCH="main"
        fi

        REPO_NAME=$(basename "$REPO_DIR")
        WORKTREES_DIR="$REPO_DIR/$USER_PREFIX"
        return 0
    fi

    # Not in a git dir — check if cwd (or a parent) is a container with main/ or master/
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/main/.git" ]]; then
            REPO_DIR="$dir"
            DEFAULT_BRANCH="main"
            MAIN_REPO="$dir/main"
            REPO_NAME=$(basename "$REPO_DIR")
            WORKTREES_DIR="$REPO_DIR/$USER_PREFIX"
            return 0
        elif [[ -d "$dir/master/.git" ]]; then
            REPO_DIR="$dir"
            DEFAULT_BRANCH="master"
            MAIN_REPO="$dir/master"
            REPO_NAME=$(basename "$REPO_DIR")
            WORKTREES_DIR="$REPO_DIR/$USER_PREFIX"
            return 0
        fi
        dir=$(dirname "$dir")
    done

    return 1
}

# Get list of worktree names (just the branch name part, not full path)
get_worktree_names() {
    if [[ ! -d "$WORKTREES_DIR" ]]; then
        return
    fi

    for dir in "$WORKTREES_DIR"/*/; do
        [[ -d "$dir" ]] && basename "$dir"
    done
}

# Select a worktree using fzf
select_worktree() {
    local prompt="$1"
    local names
    names=$(get_worktree_names)

    if [[ -z "$names" ]]; then
        echo -e "${YELLOW}No worktrees found${NC}" >&2
        return 1
    fi

    if ! command -v fzf &>/dev/null; then
        echo -e "${RED}Error: fzf is required for interactive selection${NC}" >&2
        echo "Install fzf or provide a branch name as argument" >&2
        return 1
    fi

    echo "$names" | fzf --prompt="$prompt " --height=~50% --reverse
}

usage() {
    echo -e "${BLUE}Usage:${NC}"
    echo "  wt clone <url>            Clone a repo into the wt layout"
    echo "  wt add <branch-name>      Create worktree for $USER_PREFIX/<branch-name>"
    echo "  wt rm [branch-name]       Remove worktree (fzf select if no name given)"
    echo "  wt list                   List all worktrees"
    echo "  wt cd [branch-name]       Print path to worktree (fzf select if no name)"
    echo "  wt t                      Open worktrees in tmux (fzf multi-select)"
    echo ""
    echo -e "${BLUE}Examples:${NC}"
    echo "  wt clone git@github.com:org/repo.git"
    echo "  wt add my-feature         # Creates $USER_PREFIX/my-feature worktree"
    echo "  wt rm                     # Interactive selection with fzf"
    echo "  wt cd                     # Interactive selection with fzf"
    echo "  wt t                      # Select worktrees, open each as a tmux window"
    echo ""
    echo -e "${BLUE}Structure:${NC}"
    echo "  Container:   <parent>/<repo>/"
    echo "  Main repo:   <parent>/<repo>/main/ (or master/)"
    echo "  Worktrees:   <parent>/<repo>/$USER_PREFIX/<branch-name>/"
}

cmd_clone() {
    local url="$1"

    if [[ -z "$url" ]]; then
        echo -e "${RED}Error: Repository URL required${NC}"
        echo "Usage: wt clone <url>"
        exit 1
    fi

    # Extract repo name from URL (strip trailing .git and path)
    local repo_name
    repo_name=$(basename "$url" .git)

    if [[ -d "$repo_name" ]]; then
        echo -e "${RED}Error: Directory '$repo_name' already exists${NC}"
        exit 1
    fi

    # Create container directory
    mkdir -p "$repo_name"

    # Clone into a temporary name, then rename to match the default branch
    echo -e "${BLUE}Cloning $url...${NC}" >&2
    git clone "$url" "$repo_name/main" >&2

    # Detect the default branch
    local default_branch
    default_branch=$(git -C "$repo_name/main" branch --show-current)

    if [[ "$default_branch" == "master" ]]; then
        mv "$repo_name/main" "$repo_name/master"
        echo -e "${GREEN}✓ Cloned into $repo_name/master/${NC}" >&2
        echo "$PWD/$repo_name/master"
    else
        echo -e "${GREEN}✓ Cloned into $repo_name/main/${NC}" >&2
        echo "$PWD/$repo_name/main"
    fi
}

cmd_add() {
    local branch_name="$1"

    if [[ -z "$branch_name" ]]; then
        echo -e "${RED}Error: Branch name required${NC}"
        echo "Usage: wt add <branch-name>"
        exit 1
    fi

    if ! find_repo_context; then
        echo -e "${RED}Error: Could not find git repository context${NC}"
        exit 1
    fi

    local worktree_path="$WORKTREES_DIR/$branch_name"
    local full_branch="$USER_PREFIX/$branch_name"

    echo -e "${BLUE}Repo:${NC} $REPO_NAME" >&2

    # Ensure worktrees directory exists
    mkdir -p "$WORKTREES_DIR"

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        echo -e "${YELLOW}Worktree already exists at:${NC} $worktree_path" >&2
        exit 1
    fi

    # Fetch latest from origin
    echo -e "${BLUE}Fetching latest from origin...${NC}" >&2
    git -C "$MAIN_REPO" fetch origin >&2

    # Use DEFAULT_BRANCH from find_repo_context, fall back to detection from remote
    local default_branch="${DEFAULT_BRANCH:-master}"
    if [[ -z "$DEFAULT_BRANCH" ]]; then
        if git -C "$MAIN_REPO" show-ref --verify --quiet "refs/remotes/origin/main" 2>/dev/null; then
            if ! git -C "$MAIN_REPO" show-ref --verify --quiet "refs/remotes/origin/master" 2>/dev/null; then
                default_branch="main"
            fi
        fi
    fi

    # Check if branch exists locally or remotely
    local branch_exists=false
    if git -C "$MAIN_REPO" show-ref --verify --quiet "refs/heads/$full_branch" 2>/dev/null; then
        branch_exists=true
        echo -e "${YELLOW}Branch $full_branch exists locally${NC}" >&2
    elif git -C "$MAIN_REPO" show-ref --verify --quiet "refs/remotes/origin/$full_branch" 2>/dev/null; then
        branch_exists=true
        echo -e "${YELLOW}Branch $full_branch exists on remote${NC}" >&2
    fi

    if $branch_exists; then
        # Create worktree from existing branch
        echo -e "${BLUE}Creating worktree from existing branch...${NC}" >&2
        git -C "$MAIN_REPO" worktree add "$worktree_path" "$full_branch" >&2
    else
        # Create new branch from default branch
        echo -e "${BLUE}Creating new branch $full_branch from $default_branch...${NC}" >&2
        git -C "$MAIN_REPO" worktree add --no-track -b "$full_branch" "$worktree_path" "origin/$default_branch" >&2
    fi

    echo -e "${GREEN}✓ Worktree created at:${NC} $worktree_path" >&2
    echo -e "${GREEN}✓ Branch:${NC} $full_branch" >&2

    # Print path to stdout for shell function to cd into
    echo "$worktree_path"
}

cmd_remove() {
    local branch_name="$1"

    if ! find_repo_context; then
        echo -e "${RED}Error: Could not find git repository context${NC}"
        exit 1
    fi

    # If no branch name, use fzf to select
    if [[ -z "$branch_name" ]]; then
        branch_name=$(select_worktree "Remove worktree:") || exit 1
    fi

    local worktree_path="$WORKTREES_DIR/$branch_name"
    local full_branch="$USER_PREFIX/$branch_name"

    echo -e "${BLUE}Repo:${NC} $REPO_NAME"

    # Check if worktree exists
    if [[ ! -d "$worktree_path" ]]; then
        echo -e "${RED}Error: Worktree not found at:${NC} $worktree_path"
        exit 1
    fi

    # Check if we're currently in the worktree
    if [[ "$PWD" == "$worktree_path"* ]]; then
        echo -e "${RED}Error: Cannot remove worktree while inside it${NC}"
        echo "Please cd to a different directory first"
        exit 1
    fi

    # Remove worktree
    echo -e "${BLUE}Removing worktree...${NC}"
    git -C "$MAIN_REPO" worktree remove "$worktree_path"
    echo -e "${GREEN}✓ Worktree removed${NC}"

    # Ask about branch deletion
    echo ""
    read -p "Delete local branch $full_branch? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if git -C "$MAIN_REPO" branch -d "$full_branch" 2>/dev/null; then
            echo -e "${GREEN}✓ Branch deleted${NC}"
        else
            echo -e "${YELLOW}Branch not fully merged. Force delete? [y/N]${NC}"
            read -p "" -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git -C "$MAIN_REPO" branch -D "$full_branch"
                echo -e "${GREEN}✓ Branch force deleted${NC}"
            fi
        fi
    fi
}

cmd_list() {
    if ! find_repo_context; then
        echo -e "${RED}Error: Could not find git repository context${NC}"
        exit 1
    fi

    echo -e "${BLUE}Worktrees for $REPO_NAME:${NC}"
    echo ""
    git -C "$MAIN_REPO" worktree list
}

cmd_cd() {
    local branch_name="$1"

    if ! find_repo_context; then
        echo -e "${RED}Error: Could not find git repository context${NC}" >&2
        exit 1
    fi

    # If no branch name, use fzf to select
    if [[ -z "$branch_name" ]]; then
        branch_name=$(select_worktree "Jump to worktree:") || exit 1
    fi

    local worktree_path="$WORKTREES_DIR/$branch_name"

    if [[ ! -d "$worktree_path" ]]; then
        echo -e "${RED}Error: Worktree not found at:${NC} $worktree_path" >&2
        exit 1
    fi

    # Just print the path (for use with cd)
    echo "$worktree_path"
}

cmd_tmux() {
    if ! find_repo_context; then
        echo -e "${RED}Error: Could not find git repository context${NC}"
        exit 1
    fi

    if ! command -v fzf &>/dev/null; then
        echo -e "${RED}Error: fzf is required for interactive selection${NC}"
        exit 1
    fi

    local session_name="$REPO_NAME"

    # Get all worktree paths from git
    local worktrees
    worktrees=$(git -C "$MAIN_REPO" worktree list | awk '{print $1}')

    if [[ -z "$worktrees" ]]; then
        echo -e "${YELLOW}No worktrees found${NC}"
        exit 1
    fi

    # Get window name: branch name for main/master, otherwise directory name
    get_window_name() {
        local wt_path="$1"
        local branch
        branch=$(git -C "$wt_path" rev-parse --abbrev-ref HEAD 2>/dev/null)
        if [[ "$branch" == "main" || "$branch" == "master" ]]; then
            echo "$branch"
        else
            basename "$wt_path"
        fi
    }

    # Build fzf selection list: "name\tpath"
    local selection
    selection=$(while IFS= read -r wt_path; do
        [[ -z "$wt_path" ]] && continue
        printf "%s\t%s\n" "$(get_window_name "$wt_path")" "$wt_path"
    done <<< "$worktrees" | fzf --multi --prompt="Select worktrees> " --header="TAB to select, ENTER to confirm")

    if [[ -z "$selection" ]]; then
        echo "No worktrees selected"
        exit 0
    fi

    if tmux has-session -t "$session_name" 2>/dev/null; then
        echo -e "${RED}Session '$session_name' already exists${NC}"
        exit 1
    fi

    # Create session with placeholder window
    tmux new-session -d -s "$session_name"

    # Create a window for each selected worktree
    while IFS=$'\t' read -r wt_name wt_path; do
        [[ -z "$wt_path" ]] && continue
        tmux new-window -t "$session_name" -n "$wt_name" -c "$wt_path"
    done <<< "$selection"

    # Kill the placeholder and select first worktree window
    tmux kill-window -t "$session_name:0"
    tmux select-window -t "$session_name:1"

    # Attach or switch
    if [[ -z "$TMUX" ]]; then
        tmux attach-session -t "$session_name"
    else
        tmux switch-client -t "$session_name"
    fi

    echo -e "${GREEN}Created tmux session '$session_name'${NC}"
}

# Main
case "${1:-}" in
    clone)
        cmd_clone "$2"
        ;;
    add)
        cmd_add "$2"
        ;;
    rm)
        cmd_remove "$2"
        ;;
    list|ls)
        cmd_list
        ;;
    cd)
        cmd_cd "$2"
        ;;
    t|tmux)
        cmd_tmux
        ;;
    -h|--help|help|"")
        usage
        ;;
    *)
        echo -e "${RED}Unknown command: $1${NC}"
        usage
        exit 1
        ;;
esac
